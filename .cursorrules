# Cursor Rules for PayPro Angular 20 + PrimeNG 20 Project

You are an expert Angular 20 developer working on a PayPro application. Follow these strict guidelines:

## Project Configuration
- **Framework**: Angular 20.x with standalone components
- **UI Library**: PrimeNG 20.x (native components only)
- **CSS Framework**: PrimeFlex for all layouts and styling
- **Language**: TypeScript with strict mode enabled
- **Architecture**: Signal-based reactive programming

## Angular 20 Modern Syntax

### Component Structure
```typescript
@Component({
  selector: 'app-example',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, ButtonModule],
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `...`
})
export class ExampleComponent {
  // ✅ Use inject() instead of constructor injection
  private readonly service = inject(ExampleService);
  private readonly router = inject(Router);
  
  // ✅ Use signals for reactive state
  readonly data = signal<Data[]>([]);
  readonly loading = signal(false);
  readonly error = signal<string | null>(null);
  
  // ✅ Computed signals for derived state
  readonly filteredData = computed(() => 
    this.data().filter(item => item.active)
  );
}
```

### Template Syntax
```html
<!-- ✅ Use new control flow (@if, @for, @switch) -->
@if (loading()) {
  <p-progressSpinner />
} @else if (error()) {
  <p-message severity="error" [text]="error()" />
} @else {
  @for (item of data(); track item.id) {
    <p-card [header]="item.title">
      {{ item.content }}
    </p-card>
  }
}

<!-- ✅ Use @switch for multiple conditions -->
@switch (status()) {
  @case ('loading') {
    <p-progressSpinner />
  }
  @case ('error') {
    <p-message severity="error" text="Something went wrong" />
  }
  @default {
    <p-card>Content loaded</p-card>
  }
}
```

### Forms with Modern Syntax
```typescript
interface UserForm {
  username: FormControl<string>;
  email: FormControl<string>;
  password: FormControl<string>;
}

@Component({...})
export class UserFormComponent {
  private readonly fb = inject(FormBuilder);
  
  readonly userForm = this.fb.group<UserForm>({
    username: this.fb.control('', {
      validators: [Validators.required, Validators.minLength(3)]
    }),
    email: this.fb.control('', {
      validators: [Validators.required, Validators.email]
    }),
    password: this.fb.control('', {
      validators: [Validators.required, Validators.minLength(8)]
    })
  });
  
  readonly isFormValid = computed(() => this.userForm.valid);
}
```

## PrimeNG 20 Component Usage

### Input Components
```html
<!-- ✅ Use directive form for simple inputs -->
<input pInputText 
       formControlName="username" 
       placeholder="Enter username"
       class="w-full" />

<!-- ✅ Use component form for complex inputs -->
<p-password formControlName="password" 
            placeholder="Enter password"
            [toggleMask]="true"
            [feedback]="false"
            styleClass="w-full" />

<p-calendar formControlName="date"
            placeholder="Select date"
            styleClass="w-full" />

<p-dropdown formControlName="category"
            [options]="categories()"
            placeholder="Select category"
            styleClass="w-full" />
```

### Layout Components
```html
<!-- ✅ Cards for content sections -->
<p-card header="User Information" styleClass="mb-4">
  <div class="grid">
    <div class="col-12 md:col-6">
      <label for="username">Username</label>
      <input pInputText id="username" formControlName="username" class="w-full" />
    </div>
  </div>
</p-card>

<!-- ✅ Data tables -->
<p-table [value]="users()" 
         [paginator]="true" 
         [rows]="10"
         styleClass="p-datatable-sm">
  <ng-template pTemplate="header">
    <tr>
      <th>Name</th>
      <th>Email</th>
      <th>Actions</th>
    </tr>
  </ng-template>
  <ng-template pTemplate="body" let-user>
    <tr>
      <td>{{ user.name }}</td>
      <td>{{ user.email }}</td>
      <td>
        <p-button icon="pi pi-pencil" 
                  size="small" 
                  (onClick)="editUser(user)" />
      </td>
    </tr>
  </ng-template>
</p-table>
```

### Buttons and Actions
```html
<!-- ✅ Primary actions -->
<p-button label="Save" 
          icon="pi pi-check"
          [loading]="saving()"
          [disabled]="!isFormValid()"
          (onClick)="onSave()" />

<!-- ✅ Secondary actions -->
<p-button label="Cancel" 
          severity="secondary"
          icon="pi pi-times"
          (onClick)="onCancel()" />

<!-- ✅ Icon buttons -->
<p-button icon="pi pi-trash" 
          severity="danger" 
          size="small"
          (onClick)="onDelete()" />
```

## PrimeFlex Layout System

### Flexbox Layouts
```html
<!-- ✅ Flex containers -->
<div class="flex justify-content-between align-items-center">
  <h2>Page Title</h2>
  <p-button label="Add New" />
</div>

<!-- ✅ Flex direction and wrapping -->
<div class="flex flex-column md:flex-row gap-3">
  <div class="flex-1">Content 1</div>
  <div class="flex-1">Content 2</div>
</div>

<!-- ✅ Alignment utilities -->
<div class="flex justify-content-center align-items-center min-h-screen">
  <p-card>Centered content</p-card>
</div>
```

### Grid System
```html
<!-- ✅ CSS Grid -->
<div class="grid">
  <div class="col-12 md:col-6 lg:col-4">
    <p-card>Card 1</p-card>
  </div>
  <div class="col-12 md:col-6 lg:col-4">
    <p-card>Card 2</p-card>
  </div>
  <div class="col-12 md:col-6 lg:col-4">
    <p-card>Card 3</p-card>
  </div>
</div>

<!-- ✅ No gutters for seamless design -->
<div class="grid grid-nogutter">
  <div class="col-6">Left panel</div>
  <div class="col-6">Right panel</div>
</div>
```

### Spacing and Sizing
```html
<!-- ✅ Padding and margins -->
<div class="p-4 m-2">             <!-- padding: 1.5rem, margin: 0.5rem -->
<div class="px-3 py-2">           <!-- horizontal/vertical spacing -->
<div class="pt-2 pb-4 pl-1 pr-3"> <!-- individual sides -->

<!-- ✅ Gaps -->
<div class="flex gap-2">          <!-- gap: 0.5rem -->
<div class="grid gap-4">          <!-- gap: 1.5rem -->

<!-- ✅ Width and height -->
<div class="w-full h-20rem">      <!-- width: 100%, height: 20rem -->
<div class="w-6 h-auto">          <!-- width: 50%, height: auto -->
```

### Responsive Design
```html
<!-- ✅ Responsive utilities -->
<div class="hidden md:block">Only visible on medium+ screens</div>
<div class="block md:hidden">Only visible on small screens</div>

<!-- ✅ Responsive sizing -->
<div class="w-full md:w-6 lg:w-4">Responsive width</div>

<!-- ✅ Responsive flex direction -->
<div class="flex flex-column md:flex-row">
  <div>Item 1</div>
  <div>Item 2</div>
</div>
```

## Services and State Management

### Modern Service Pattern
```typescript
@Injectable({ providedIn: 'root' })
export class UserService {
  private readonly http = inject(HttpClient);
  
  // ✅ Signal-based state
  private readonly _users = signal<User[]>([]);
  private readonly _loading = signal(false);
  private readonly _error = signal<string | null>(null);
  
  // ✅ Read-only public signals
  readonly users = this._users.asReadonly();
  readonly loading = this._loading.asReadonly();
  readonly error = this._error.asReadonly();
  
  async loadUsers(): Promise<void> {
    this._loading.set(true);
    this._error.set(null);
    
    try {
      const users = await firstValueFrom(
        this.http.get<User[]>('/api/users')
      );
      this._users.set(users);
    } catch (error) {
      this._error.set('Failed to load users');
    } finally {
      this._loading.set(false);
    }
  }
}
```

### Functional Guards and Interceptors
```typescript
// ✅ Functional guard
export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  
  if (authService.isAuthenticated()) {
    return true;
  }
  
  return router.createUrlTree(['/login']);
};

// ✅ Functional interceptor
export const authInterceptor: HttpInterceptorFn = (req, next) => {
  const authService = inject(AuthService);
  const token = authService.getToken();
  
  if (token) {
    req = req.clone({
      setHeaders: { Authorization: `Bearer ${token}` }
    });
  }
  
  return next(req);
};
```

## Forbidden Practices

### ❌ Don't Do This
```typescript
// ❌ Constructor injection (use inject() instead)
constructor(private service: MyService) {}

// ❌ Old control flow
*ngIf="condition"
*ngFor="let item of items"

// ❌ Custom CSS overrides on PrimeNG
.p-button { background: red !important; }

// ❌ Manual DOM manipulation
@ViewChild('element') element: ElementRef;
this.element.nativeElement.style.color = 'red';

// ❌ Subscribing without proper cleanup
ngOnInit() {
  this.service.getData().subscribe(data => {
    this.data = data;
  });
}
```

### ✅ Do This Instead
```typescript
// ✅ Modern injection
private readonly service = inject(MyService);

// ✅ New control flow
@if (condition) { ... }
@for (item of items; track item.id) { ... }

// ✅ PrimeFlex utilities
class="bg-primary text-white border-round p-3"

// ✅ Signal-based state
readonly data = signal<Data[]>([]);

// ✅ Use signals or async pipe
@Component({
  template: `
    @for (item of data(); track item.id) {
      <div>{{ item.name }}</div>
    }
  `
})
```

## Code Quality Standards
- Always use TypeScript strict mode
- Implement proper error handling
- Use OnPush change detection strategy
- Write comprehensive unit tests
- Follow SOLID principles
- Prefer composition over inheritance
- Use meaningful variable and function names
- Add JSDoc comments for public APIs

Remember: Always use PrimeNG components as-is without style overrides, use PrimeFlex for all layouts, and leverage Angular 20's modern features like signals and new control flow syntax.
